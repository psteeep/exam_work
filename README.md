# exam_work

№1
Односвязний список - це динамічна структура даних, яка скаладається з фузлів, які в свою чергу мають два поля, а саме адрес і беспосередньо дані. 
За допомогою адреси ми може отримувати доступ до даних. Відміною від звиачайного масиву (також перевагами) є те що список це не послідовна область
у памяті, тобто дані зберігаються будь-де у памяті, важливо тільки мати адресу, також не потрібно знати заздалегіть розмір списку. В односвязний список 
легко можна додавати дані, на початку, в кцін, по середині. Останій елемент у списку матиме вказівник на адресу NULL тобто після нього немає даних. 
Недоліком односвясного спику є те що щоб отримати певні дані потрібного обходити все від початку до потрібної інформаці. що може буть достатньо затратно по часу. 
Скалдність такого пошуку o(n).

Масив - впорядкований набір фіксованої кількості однотипних елементів, що зберігаються в послідовно розташованих комірках оперативної пам'яті, мають порядковий номер і спільне
ім'я, що надає користувач. 
Достаньо прблематично є доати новий запис у масив, для цього буд епотрібно створити новий масив (це вже динамічні масиви) на 1 комірку більшої розмірості, перезаписати всі
попередні дані в новий масив, додати нові дані, очисти 
память від старого масив, і змінити назву у вказівнику. Це достаньо затратно і не раціонально, але масиви зручні коли наперед відома кіслькість даних і вона ніяк не буде
змінюватися. 
Такж перевагою є те що до любого елементу можна звернутися за індексом не обходячи всі( скалдність О(1)), так не вдасться з односвязним списком

Отже висновок такий, масиви бдуть зручіні коли нам заздалегіть відомом кількість даних, і потрібно легко і бистро отримувати доступ до них. Як тілльки буде потребність
розширювати, добавити, видаляти дані, то звичайно буде раціональніше використовувати связний список.




№2
Успадкування один з основних принципиві ооп, воно дозволяє виділити спільну частину логіки декількох споріднених класів в один базовий клас, самі класи зробивши при цьому його
нащадками, що уточнюють його поведінку. Використання успудакування класів є один із засобіві уникнення дублювання коду. Перед успадкуванняя потрібно мати розуміння ієрархії
класів. Успадкування буває двох типів: множинне та одиночне. Праклод є клас Автомобіль(батьківський клас, клас предок), нащадкамаи до цього класу будуть - клас Седан,
Позашляховик, Спорткар і тд. ТОбто все це автомобілі які мають багато спільного описаного в класі Автомобіль, але кожен з них має нюанси різні і які будуть описані класах
нащадках.

Приклад коду з наслідуванням:

    class Parent {
    public:
	
	    Parent() {
		     cout << "Parent constructtor" << endl;
	    }

	   ~Parent() {
		     cout << "Parent destructor" << endl;
	  } 

    };


    class Child : public Parent {
    public:
	   Child() {
		  cout << "Child constructtor" << endl;
	    }

	  ~Child() {
		  cout << "Child destructor" << endl;
	  }

    };
    
Наведена проста ієрархія двох класів і виклик їхніх конструкторів при вклику Child obj; буде склідуючий вивід 

Parent constructtor

Child constructtor

Child destructor

Parent destructor




